[{"categories":null,"contents":"   BANCO - A crude bank backend API  Project Link\n   FUNCTIONALITY   Create User in the banco system  Each user can create multiple accounts, but accounts must have different currency Only user, authenticated into banco system can manage their accounts(create, list, update, delete - CRUD)   Transactions - money can be transferred from one user account to other  To perform transaction, user must be authenticated into banco system User can only send money from their account Transaction can only take place between accounts of same currency Each transaction is consistent       DB design/architecture     TECHNICAL DETAILS   Database setup scripts in scripts/db.sh SQLC to generate models and crud code golang-migrate for migrations environment variable setup in makefile (best practice) Nice way to implements DB transaction for money transfer  transaction lock and deadlock handling while updating user account balances For each transaction transfer details are stored in transfer table(fromAccount, toAccount, amount) Two entries created in entry table, how much money got added/deducted from toAccount and fromAccount Update account balance of fromAccount and toAccount   Testing  Unit tests Integration tests testing via mocking (dependency injection - db layer is injected into api layer) go-mockery is used for mocking Test containers are used to run integration tests There is no service layer, as it seems to be a little overkill for this project.   In api request - custom param validator (used reflection) User password encryption using bcrypt Use Paseto based user authentication  JWT authentication code is also present Interface is used for Token based authentication So, you can easily replace Paseto with JWT   Github Actions is used as Pipeline Docker and docker compose setup Pushing latest images to digital oceans private registry on push  ","date":"Oct 05","permalink":"https://rahilrehan.github.io/projects/a_project/","tags":null,"title":"Banco"},{"categories":["concepts"],"contents":"   What is Software Development/Engineering?  Software engineering is defined as the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software. - IEEE\u0026rsquo;s Standard Glossary\nSoftware devlopment is not just writing code, its about writing clean, understandable and maintainable code. And there are many other things involved in software development process. Things like requiremnt gathering, planning, desinging, testing, releasing and later maintaining. These aspects are also very important!\nLike Martin Fowler said, “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”\n   Types of software engineers:  SDE(Software development engineer) - A common term used to represent an umbrella of professions.\n Frontend engineers: Folks who deal with visual components of the product. Backend engineers: Folks who deal with internal system components providing an abstraction in form of APIs which frontend engineers can use. Fullstack engineers: Combination of both of the above roles. System Architect: The system designer, makes sure the systems design is good . SDET(tester): One who test the whole system for bugs and acceptance critereas.  In some companies testing is part of development process, so this role is played by SDE itself. Ex: in TDD   Operations engineer: Deals with releasing the product to market. Deployment and stuff. SRE - Site reliability engineers: Folks who work both on development teams and operations teams(release teams) Devops engineer: Acts as a middleman between devolopment teams and operations team. It\u0026rsquo;s more of a culture. So, some companies may not have this role at all.     Testing   Acceptance tests: end-to-end tests to ensure the whole system adheres to business requirements. Performance, Load, Regression testing: Even though all the test cases pass, system has to be performant, should be able to handle load etc. These tests evaluate above metrics.     Software Development Models:     Waterfall model:  Steps in waterfall model:\n Requirement collection (customer requirement) Desgin (design system accordingly) Implementation (build system) Verification (verify if the product meets the initial requriements) Maintenance (Maintain the project)  In this model we assume that all requirements are collected before implementation (which is almost never the case!)\n   Iterative Model:  Steps in iterative model:\n Requirement collection Design Implement Verify Jump to 1st step(and repeat)   Repeat this until the customer is satisfied ^^ Problem from waterfall model is solved!     Agile!   Agile itself is not a model, it is an umbrella term. Agile way says,  we have to build software in iterative, incrementing, short cycles. Intra-team(cross-team) communication is key to reduce conflicts in future.       Some models of agile:     Lean development:[copied from wiki]   Eliminate waste : do not add anything which is not required. Amplify learning: gather requirments constantly, share knowledge among teams. Decide as late as possible: conter-intuitive? nah, just don\u0026rsquo;t commit early. Deliver ASAP: the faster the deliver, the faster the feedback and faster the cycle repeats. Empower the team: Important. Optimize the whole: Always think about how the system works on the whole.     SCRUM!!   The whole project is broken down into chunks. Each chunk is divided such that it can be completed in 2-4 weeks. And this timeframe to complete a chuck is called sprint. Each chunk of work is again divided into tasks which people can pickup and complete. Number of tasks completed in a sprint gives teams velocity. Balance the velocity, it shouldn\u0026rsquo;t be too high(easy tasks) or too low(hard tasks). The tasks which are not completed(spillovers) are again put into next sprint. Scrum events:  Planning - Initial planning of whole project Estimation - Splitting into chunks Daily standups - Daily updates(what was done yesterday, what will be done today, any blockers?) - each team member talks about these three points in short. Retrospection - After each sprint, what went well and what can be improved must be discussed among team. And actions items have to be planned accordingly.       Kanban   A board style todo-list. Contains lanes  TODO/Backlog Doing Review Done   More lanes can be added according to teams need and style Ex: Trello     Devops!   Popular! People are switching to microservice architecture. As number of services increase in microservice architecture, each team which is responsible for a service owns the service. Hence, team should also be involved in operations related tasks! Devops itself has become a new role now-a-days. It was just a culture before\u0026hellip;  ","date":"Oct 18","permalink":"https://rahilrehan.github.io/post/software-engineering-lifecycle/","tags":["software engineering"],"title":"Software Development Lifecycle"},{"categories":["concepts"],"contents":"   Basics   Spring has lot of modules start.spring.io lists many spring modules which you can configure spring boot is useful to build RESTfull web services. It makes developing spring applications easy by auto configuring default components. It is opinionated framework fat jar -\u0026gt; also includes tomcat. better solution if you want to deploy on cloud platforms     Dependency Injection   Assume mail sender example, where we can have mailSender of type SMTP, POPM or MockMail. We can have an interface MailSender which defines the common functionality and we implement the interface in SMTP, POPM or Mock class. **Problem: object creation will be like: **  private MailSender = new SMTPMailSender() private MailSender = new POPMMailSender() private MailSender = new MockMailSender() we need to hardcode the type while creating object can we automate this? Add @Component annotation to any class which implements MailSender Add @Autowired annotation when creating object how does it work:  When application starts all the beans gets setup  Beans: annotations at top level, whose object will be created and stored in Application Context Beans examples: @Component, @RestController   When application is running and when we create objects variables for which we have annotations like @Autowired. Objects which were already created from application context are assigned to current variables. i.e those objects from application context are injected into these variables and hence dependency injection     @Autowired also works on methods(setters, constructors, getters, any methods..) Multiple beans problem: when we create two classes from same interface and add @component annotation to both classes, and create object using interface using @autowired annotation, spring will be confused to choose between beans  one solution is to use camel-case variable names while creating objects which resemble the name of the class you want (ex: smtpMailSender) you can also add name param to @component -\u0026gt; @component(\u0026ldquo;mockMail\u0026rdquo;), and create object using the name mockMail use extra @primary annotation, the bean which has this will get preference you can also use @qualifier annotation to class, and also use @qualifier in setter or constructor, \u0026hellip;etc   Prefer constructor injection @resource and @inject are similar to @autowired, but @autowired is very powerful, so use @autowired Specializations of @component annotations  @Controller @Service @Repository @Configuration @SpringBootApplication(scanBasePackageClasses = {default.class, abc.class}) - scans through the package and puts any dependency injection components into application context @RestController \u0026hellip;.. many others   what if you import a dependency and you have to create object from there, you cannot add @component annotation dependency package  Create a new config class, which has methods to return objects from the external dependency the new config class must have @Configuration annotation and methods must have @Bean configuration names of the methods can be used for object variable names   use @Value annotation to access variables from .properties or .yaml files an external config file takes more preference over internal config(application.properties) **Profiles: **A spring application can be configure to behave differently in different environments using profiles  ex environments: dev, test, prod provide in application.properties:  spring.profiles.active: book, dev   you can also use particular beans in particular environments!  just\tuse @Profile(\u0026ldquo;envName\u0026rdquo;), can accepts bool, !envName   @Conditional annotation, include or exclude beans based on arbitrary conditions  @ConditionalOnClass, OnProperty, OnMissingBean ..etc configure bean based on presence of application property =\u0026gt; @ConditionalOnProperty     In @Configuration classes, when we try to create same bean again from some method, spring still returns the cached bean only.  Caching does not happen when we use @Component annotation   Always use @Configuration Classes  ","date":"Oct 09","permalink":"https://rahilrehan.github.io/post/dependecy-injection-spring/","tags":["java"],"title":"Dependency Injection - Spring"},{"categories":["microservices","backend"],"contents":"   Microservices Concepts (Using Java technologies)  In microservices we can have multiple services running, and each service can have multiple instances as well.\nProduct service: browse products using rest api Order service: places order Inventory service: checks if product is available in inventory Notification service:\n   Discovery Service   Each service can have multiple instances running and they need to discover each other. As we cannot particularly specify the service as they are multiple instances, referring to different service needs to be generic. Referring to one service means to refer to available services. In java we can use spring cloud netflix eureka     Centralized configuration   If we change a config variable in code, we need to make change to code, compile and re-deploy it again. If we have multiple instances of same service then it becomes hard as we need to take down those services as well . Solution: Use a centralized config server Store all config variables of different services in different files in a git repository or local store. Whenever there is change in these files, config server will have new config variables. Now to refresh all the config variables in runtime, you need to call to some api actuator which will refresh the config variables in that service and all its instances. In Java Central config server with automatic refresh     Storing secrets in vault   usernames, passwords, database links etc have to be hidden from configuration We have to install vault in our system or via docker, starting vault will start a server as well. Save all the secrets in vault. In Java we can use Spring starter vault config to use secrets in our code. It\u0026rsquo;s enough just to connect to vault server and all the secrets are made available to the service.     Message Broker   One service might depend on other service, change in config variable of one service may effect the other. We can use message broker like RabbitMQ, which broadcast that there is some change in config to other services which are subscribed to that service which has changes. RabbitMQ must be installed on the host system and runs on some host and port. RabbitMQ in infra?     API gateway   We may have different services in our application. Each service may handle different endpoints. API gateway, receives a uri request from clients. It redirects the client to correct service. It acts like a central endpoint distributer. We can attach load balancers to each service as well. Authentication, monitoring and rete limiting can also be taken care here. API gateway is also a service and should be present in discovery service. In Java, spring cloud gateway     Sercuring server with authentication and authorization   Run keycloak on host machine, it will start at some port token relay:  If authentication is done by token, using keycloak as we will be authorizing at api gateway, we need to send this token to the respective gateway as well.   In Java, use Keycloak     Resilience   Order service asynchronously communicates with Inventory service Inventory service can go down, so we need to make it resilient RequestInterceptor:  When one service is speaking to other, authentication token is not sent. Because, it is not token relay mechanism. For passing auth token, we need to get the token and append it to authorization bearer in the request header and then send the request to service.   Definition: watch for service outages and network latencies and temporarily stop the service until service starts functioning normally again . In Java, Resilience4g or hystrix(netflix - not maintained right now)     Event driven microservices architecture   When order is placed, order service broadcasts message to notification service via RabbitMQ. Use rabbitMQ binders to listen for events  output binders: to send notifications input binders: to receive notifications       Distributed tracing   microservices pattern allows us to track the requests from one microservice to other. We give unique id along the journey of the request each request has same trace id along its journey but when there is a circuit breaker in between, trace id changes as circuit breaker spawns a new thread. But there is a workaround to keep our trace id same(traceableExecuterService in Java) In java, we use spring cloud sleuth and zipkin     Centralized logging   logs are all over different services place all logs in a centralized manner First we need to use some logging library at each service like log4J or logback beware of security issues while logging In java (ELK stack is popular -\u0026gt; elastic search, logstash and kibana)  logstash: application services send logs to logstash over tcp. these logs are then sent from logstash to elastic search.  phases:\t(configure in logstash.conf)  input: from services using tcp or ftp or rabbitMQ filter: filter logs output: send to elastic search     Elastic search(search engine implementation in java): Used to store logs  Each service has its own index in elastic search   Kibana: Visualize, Query and filter elastic search data       End   Do not use microservice architecture unless there is a need. Monoliths are best in most cases.  ","date":"Oct 09","permalink":"https://rahilrehan.github.io/post/microservices-concepts-java/","tags":["java"],"title":"Microservices Concepts - Java"},{"categories":["concepts"],"contents":" The art of a good night\u0026rsquo;s sleep is knowing you will not get woken by a support call and the piece of mind from being able to confidently change your software in an always moving market. - Nic Jackson change in code can have undesirable effect on the other parts, tests helps in making the process of changing code in future easy testing pyramid: unit testing(bottom), service/integration(middle), ui/end-end(top)  test cases should decrease as you go from bottom to top        Approach   Just write test first (use expected function) Run and fail the test Write minimal code for the test to run and fail Write minimal code to make test pass Test same function with different values Make sure all tests are passing Tests for base cases Refactor both code and tests     Features and scenarios   Given a feature, break it down to scenarios. Each feature is a user story  Example Feature: As a user when I call the search endpoint, I would like to receive a list of kittens Break it down to scenarios  1st Scenario: Invalid query\nGiven I have no search criteria\nWhen I call the search endpoint\nThen I should receive a bad request message and so\u0026hellip; on number of different scenarios         Uncle bobs, rules of unit tests   First law: You may not write production code until you have written a failing unit test Second law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing Third law: You may not write more production code than is sufficient to pass the currently failing test     Naming   my convention: TestNameReturnSomethingWhenSomethingHappens  example: TestDogHandlerReturnsBadRequestWhenNoSearchCriteriaIsSent       AAA format for testing - Arrange, Act, Assert   I always try to follow this pattern for clean code  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class CalculatorTest{ public void sumOfTwoNumbers(){ //Arrange \tdouble first = 10; double second = 20; var Calc = new Calculator(); //Act \tdouble result = Calc.Sum(first, second); //Assert \tAssert.Equal(30, result); } }      concepts   Idempotency Side effects A stub is a fake class that comes with preprogrammed return values. It’s injected into the class under test to give you absolute control over what’s being tested as input. A typical stub is a database connection that allows you to mimic any scenario without having a real database. A mock is a fake class that can be examined after the test is finished for its interactions with the class under test. For example, you can ask it whether a method was called or how many times it was called. Typical mocks are classes with side effects that need to be examined, e.g. a class that sends emails or sends data to another external service. Learn mocking - https://semaphoreci.com/community/tutorials/stubbing-and-mocking-with-mockito-2-and-junit Wrapper: something which hides implementation of some other code or internally uses other code.  ","date":"Oct 09","permalink":"https://rahilrehan.github.io/post/test-driven-development-notes/","tags":["testing"],"title":"Test Driven Development - Notes"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://rahilrehan.github.io/articles/","tags":null,"title":"Articles"}]