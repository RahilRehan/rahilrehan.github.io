[{"categories":null,"contents":"   FEATURES   nice db setup scripts sqlc model and crud generation golang migrate migrations enviroment variable setup in makefile Nice way to implements DB transaction for money transfer  transaction lock and deadlock haldling while updating user account balances   using gin framework for routing etc using viper to read configs     THINGS TO IMPROVE ON   folder structure dependency injection testing coming up with own design(i.e efficiently using golang libraries) Have sections for local setup and production setup implement test suites and test containers Learn concept of deadlock and db transactions in depth, watch video 7 and 8 again  ","date":"Oct 05","permalink":"https://rahilrehan.github.io/projects/a_project/","tags":null,"title":"Banco"},{"categories":["microservices","backend"],"contents":"   Microservices Concepts (Using Java technologies)  In microservices we can have multiple services running, and each service can have multiple instances as well.\nProduct service: browse products using rest api Order service: places order Inventory service: checks if product is available in inventory Notification service:\n   Discovery Service   Each service can have multiple instances running and they need to discover each other. As we cannot particularly specify the service as they are multiple instances, referring to different service needs to be generic. Referring to one service means to refer to available services. In java we can use spring cloud netflix eureka     Centralized configuration   If we change a config variable in code, we need to make change to code, compile and re-deploy it again. If we have multiple instances of same service then it becomes hard as we need to take down those services as well . Solution: Use a centralized config server Store all config variables of different services in different files in a git repository or local store. Whenever there is change in these files, config server will have new config variables. Now to refresh all the config variables in runtime, you need to call to some api actuator which will refresh the config variables in that service and all its instances. In Java Central config server with automatic refresh     Storing secrets in vault   usernames, passwords, database links etc have to be hidden from configuration We have to install vault in our system or via docker, starting vault will start a server as well. Save all the secrets in vault. In Java we can use Spring starter vault config to use secrets in our code. It\u0026rsquo;s enough just to connect to vault server and all the secrets are made available to the service.     Message Broker   One service might depend on other service, change in config variable of one service may effect the other. We can use message broker like RabbitMQ, which broadcast that there is some change in config to other services which are subscribed to that service which has changes. RabbitMQ must be installed on the host system and runs on some host and port. RabbitMQ in infra?     API gateway   We may have different services in our application. Each service may handle different endpoints. API gateway, receives a uri request from clients. It redirects the client to correct service. It acts like a central endpoint distributer. We can attach load balancers to each service as well. Authentication, monitoring and rete limiting can also be taken care here. API gateway is also a service and should be present in discovery service. In Java, spring cloud gateway     Sercuring server with authentication and authorization   Run keycloak on host machine, it will start at some port token relay:  If authentication is done by token, using keycloak as we will be authorizing at api gateway, we need to send this token to the respective gateway as well.   In Java, use Keycloak     Resilience   Order service asynchronously communicates with Inventory service Inventory service can go down, so we need to make it resilient RequestInterceptor:  When one service is speaking to other, authentication token is not sent. Because, it is not token relay mechanism. For passing auth token, we need to get the token and append it to authorization bearer in the request header and then send the request to service.   Definition: watch for service outages and network latencies and temporarily stop the service until service starts functioning normally again . In Java, Resilience4g or hystrix(netflix - not maintained right now)     Event driven microservices architecture   When order is placed, order service broadcasts message to notification service via RabbitMQ. Use rabbitMQ binders to listen for events  output binders: to send notifications input binders: to receive notifications       Distributed tracing   microservices pattern allows us to track the requests from one microservice to other. We give unique id along the journey of the request each request has same trace id along its journey but when there is a circuit breaker in between, trace id changes as circuit breaker spawns a new thread. But there is a workaround to keep our trace id same(traceableExecuterService in Java) In java, we use spring cloud sleuth and zipkin     Centralized logging   logs are all over different services place all logs in a centralized manner First we need to use some logging library at each service like log4J or logback beware of security issues while logging In java (ELK stack is popular -\u0026gt; elastic search, logstash and kibana)  logstash: application services send logs to logstash over tcp. these logs are then sent from logstash to elastic search.  phases:\t(configure in logstash.conf)  input: from services using tcp or ftp or rabbitMQ filter: filter logs output: send to elastic search     Elastic search(search engine implementation in java): Used to store logs  Each service has its own index in elastic search   Kibana: Visualize, Query and filter elastic search data       End   Do not use microservice architecture unless there is a need. Monoliths are best in most cases.  ","date":"Oct 09","permalink":"https://rahilrehan.github.io/post/microservices-concepts-java/","tags":["java","microservices"],"title":"Microservices Concepts - Java"},{"categories":["testing"],"contents":" The art of a good night\u0026rsquo;s sleep is knowing you will not get woken by a support call and the piece of mind from being able to confidently change your software in an always moving market. - Nic Jackson change in code can have undesirable effect on the other parts, tests helps in making the process of changing code in future easy testing pyramid: unit testing(bottom), service/integration(middle), ui/end-end(top)  test cases should decrease as you go from bottom to top        Approach   Just write test first (use expected function) Run and fail the test Write minimal code for the test to run and fail Write minimal code to make test pass Test same function with different values Make sure all tests are passing Tests for base cases Refactor both code and tests     Features and scenarios   Given a feature, break it down to scenarios. Each feature is a user story  Example Feature: As a user when I call the search endpoint, I would like to receive a list of kittens Break it down to scenarios  1st Scenario: Invalid query\nGiven I have no search criteria\nWhen I call the search endpoint\nThen I should receive a bad request message and so\u0026hellip; on number of different scenarios         Uncle bobs, rules of unit tests   First law: You may not write production code until you have written a failing unit test Second law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing Third law: You may not write more production code than is sufficient to pass the currently failing test     Naming   my convention: TestNameReturnSomethingWhenSomethingHappens  example: TestDogHandlerReturnsBadRequestWhenNoSearchCriteriaIsSent       AAA format for testing - Arrange, Act, Assert   I always try to follow this pattern for clean code  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class CalculatorTest{ public void sumOfTwoNumbers(){ //Arrange \tdouble first = 10; double second = 20; var Calc = new Calculator(); //Act \tdouble result = Calc.Sum(first, second); //Assert \tAssert.Equal(30, result); } }      concepts   Idempotency Side effects A stub is a fake class that comes with preprogrammed return values. It’s injected into the class under test to give you absolute control over what’s being tested as input. A typical stub is a database connection that allows you to mimic any scenario without having a real database. A mock is a fake class that can be examined after the test is finished for its interactions with the class under test. For example, you can ask it whether a method was called or how many times it was called. Typical mocks are classes with side effects that need to be examined, e.g. a class that sends emails or sends data to another external service. Learn mocking - https://semaphoreci.com/community/tutorials/stubbing-and-mocking-with-mockito-2-and-junit Wrapper: something which hides implementation of some other code or internally uses other code.  ","date":"Oct 09","permalink":"https://rahilrehan.github.io/post/test-driven-development-notes/","tags":["testing"],"title":"Test Driven Development - Notes"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://rahilrehan.github.io/articles/","tags":null,"title":"Articles"}]